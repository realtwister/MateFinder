<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Mate Finder: Board Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mate Finder
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classBoard-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Board Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Board_8h_source.html">Board.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9ee491d4fea680cf69b033374a9fdfcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ee491d4fea680cf69b033374a9fdfcb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a9ee491d4fea680cf69b033374a9fdfcb">Board</a> ()</td></tr>
<tr class="memdesc:a9ee491d4fea680cf69b033374a9fdfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor, defaulting to the starting position. <br /></td></tr>
<tr class="separator:a9ee491d4fea680cf69b033374a9fdfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155259ecd3131cbf8c155c1dd19026b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a155259ecd3131cbf8c155c1dd19026b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a155259ecd3131cbf8c155c1dd19026b0">Board</a> (const char *str)</td></tr>
<tr class="memdesc:a155259ecd3131cbf8c155c1dd19026b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from FEN string. <br /></td></tr>
<tr class="separator:a155259ecd3131cbf8c155c1dd19026b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd2a85d6b43bcab4eaf83e1541aeb18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a8dd2a85d6b43bcab4eaf83e1541aeb18">Board</a> (const char *str, const bool file)</td></tr>
<tr class="memdesc:a8dd2a85d6b43bcab4eaf83e1541aeb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from FEN notation from file or string and calculate legal moves.  <a href="#a8dd2a85d6b43bcab4eaf83e1541aeb18">More...</a><br /></td></tr>
<tr class="separator:a8dd2a85d6b43bcab4eaf83e1541aeb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7768fd4eb1c86f89dd50692921228f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7768fd4eb1c86f89dd50692921228f0"></a>
<a class="el" href="namespacePiece.html#a588233307aa6bdb32c1d62c9f20895cc">Piece::Piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#af7768fd4eb1c86f89dd50692921228f0">getSquare</a> (const <a class="el" href="structsquare.html">square</a>&lt; int &gt; pos) const </td></tr>
<tr class="memdesc:af7768fd4eb1c86f89dd50692921228f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get what piece is occupying the given square. <br /></td></tr>
<tr class="separator:af7768fd4eb1c86f89dd50692921228f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab48b0f0af13688b51a05309b2a3da6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab48b0f0af13688b51a05309b2a3da6e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#aab48b0f0af13688b51a05309b2a3da6e">isCheck</a> () const </td></tr>
<tr class="memdesc:aab48b0f0af13688b51a05309b2a3da6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the player to move is checked. <br /></td></tr>
<tr class="separator:aab48b0f0af13688b51a05309b2a3da6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa3dcd69de0f9e553a971f6dd83f69b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfa3dcd69de0f9e553a971f6dd83f69b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#acfa3dcd69de0f9e553a971f6dd83f69b">blackToMove</a> () const </td></tr>
<tr class="memdesc:acfa3dcd69de0f9e553a971f6dd83f69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether black is to move. <br /></td></tr>
<tr class="separator:acfa3dcd69de0f9e553a971f6dd83f69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7df4c9d18b4c42d133a21aea6b8485f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7df4c9d18b4c42d133a21aea6b8485f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#ad7df4c9d18b4c42d133a21aea6b8485f">isMate</a> () const </td></tr>
<tr class="memdesc:ad7df4c9d18b4c42d133a21aea6b8485f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the current position is mate. <br /></td></tr>
<tr class="separator:ad7df4c9d18b4c42d133a21aea6b8485f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5103bd00afbe361f7aa14c098ee43b57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5103bd00afbe361f7aa14c098ee43b57"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a5103bd00afbe361f7aa14c098ee43b57">isDraw</a> () const </td></tr>
<tr class="memdesc:a5103bd00afbe361f7aa14c098ee43b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the current position is drawn. <br /></td></tr>
<tr class="separator:a5103bd00afbe361f7aa14c098ee43b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993b2839790b3fbe4b1c6ba2a2257fe1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a993b2839790b3fbe4b1c6ba2a2257fe1"></a>
<a class="el" href="structmoveArray.html">moveArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a993b2839790b3fbe4b1c6ba2a2257fe1">getMoves</a> ()</td></tr>
<tr class="memdesc:a993b2839790b3fbe4b1c6ba2a2257fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of legal moves. <br /></td></tr>
<tr class="separator:a993b2839790b3fbe4b1c6ba2a2257fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5732564ae8ce7f247072ded83f71dc75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a5732564ae8ce7f247072ded83f71dc75">execMove</a> (const <a class="el" href="structmove.html">move</a> mv)</td></tr>
<tr class="memdesc:a5732564ae8ce7f247072ded83f71dc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a move.  <a href="#a5732564ae8ce7f247072ded83f71dc75">More...</a><br /></td></tr>
<tr class="separator:a5732564ae8ce7f247072ded83f71dc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33aaf879882d2c1abbab14c9727f2f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac33aaf879882d2c1abbab14c9727f2f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#ac33aaf879882d2c1abbab14c9727f2f9">changeColor</a> ()</td></tr>
<tr class="memdesc:ac33aaf879882d2c1abbab14c9727f2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the color of the player that is to move. <br /></td></tr>
<tr class="separator:ac33aaf879882d2c1abbab14c9727f2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f148daa03da25d40dff3fc613568d6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f148daa03da25d40dff3fc613568d6f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a5f148daa03da25d40dff3fc613568d6f">clearBoard</a> ()</td></tr>
<tr class="memdesc:a5f148daa03da25d40dff3fc613568d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the entire board. <br /></td></tr>
<tr class="separator:a5f148daa03da25d40dff3fc613568d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a15fa8b4b4db9d11093c6c806344fc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a15fa8b4b4db9d11093c6c806344fc6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a2a15fa8b4b4db9d11093c6c806344fc6">setPiece</a> (const <a class="el" href="structsquare.html">square</a>&lt; int &gt; sq, const <a class="el" href="namespacePiece.html#a588233307aa6bdb32c1d62c9f20895cc">Piece::Piece</a> piece)</td></tr>
<tr class="memdesc:a2a15fa8b4b4db9d11093c6c806344fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a piece on a given square. <br /></td></tr>
<tr class="separator:a2a15fa8b4b4db9d11093c6c806344fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2523a362ab327fb628f4f226db52de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBoard.html">Board</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#aef2523a362ab327fb628f4f226db52de">cloneAndExecMove</a> (const <a class="el" href="structmove.html">move</a> mv) const </td></tr>
<tr class="memdesc:aef2523a362ab327fb628f4f226db52de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the current position and execute a move.  <a href="#aef2523a362ab327fb628f4f226db52de">More...</a><br /></td></tr>
<tr class="separator:aef2523a362ab327fb628f4f226db52de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b38efec8c8ce21b55546da09685a3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a58b38efec8c8ce21b55546da09685a3e">printBoard</a> () const </td></tr>
<tr class="memdesc:a58b38efec8c8ce21b55546da09685a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a formatted representation of the board.  <a href="#a58b38efec8c8ce21b55546da09685a3e">More...</a><br /></td></tr>
<tr class="separator:a58b38efec8c8ce21b55546da09685a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a6f2173ec700556df381b6623a5482850"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f2173ec700556df381b6623a5482850"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>stateFlags</b> : char { <br />
&#160;&#160;<b>checkMask</b> = 0x01, 
<b>whiteCastleKingsideMask</b> = 0x02, 
<b>whiteCastleQueensideMask</b> = 0x04, 
<b>blackCastleKingsideMask</b> = 0x08, 
<br />
&#160;&#160;<b>blackCastleQueensideMask</b> = 0x10, 
<b>blackToMoveMask</b> = 0x20, 
<b>drawMask</b> = 0x40
<br />
 }</td></tr>
<tr class="separator:a6f2173ec700556df381b6623a5482850"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a49045c77d568e4b5a00f176a2add54c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a49045c77d568e4b5a00f176a2add54c8">fromStr</a> (const char *str)</td></tr>
<tr class="memdesc:a49045c77d568e4b5a00f176a2add54c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the FEN notation from a string.  <a href="#a49045c77d568e4b5a00f176a2add54c8">More...</a><br /></td></tr>
<tr class="separator:a49045c77d568e4b5a00f176a2add54c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4043087fc35e9706d0e83ec07225fe33"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a4043087fc35e9706d0e83ec07225fe33">fromFile</a> (const char *fileName)</td></tr>
<tr class="memdesc:a4043087fc35e9706d0e83ec07225fe33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the FEN notation from a file.  <a href="#a4043087fc35e9706d0e83ec07225fe33">More...</a><br /></td></tr>
<tr class="separator:a4043087fc35e9706d0e83ec07225fe33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d3ebb2342b74d9455a89924a54aa14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#ad4d3ebb2342b74d9455a89924a54aa14">calcMoves</a> ()</td></tr>
<tr class="memdesc:ad4d3ebb2342b74d9455a89924a54aa14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate legal moves.  <a href="#ad4d3ebb2342b74d9455a89924a54aa14">More...</a><br /></td></tr>
<tr class="separator:ad4d3ebb2342b74d9455a89924a54aa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70526dde51ab18ec4011c07a7e38e60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#aa70526dde51ab18ec4011c07a7e38e60">getPieceMoves</a> (<a class="el" href="structmoveArray.html">moveArray</a> &amp;result, const <a class="el" href="structcheck.html">check</a> &amp;kingEnv, const <a class="el" href="structsquare.html">square</a>&lt; int &gt; curPos, const <a class="el" href="structsquare.html">square</a>&lt; int &gt; kingPos)</td></tr>
<tr class="memdesc:aa70526dde51ab18ec4011c07a7e38e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the legal moves of the piece on square&lt;int&gt; curPos.  <a href="#aa70526dde51ab18ec4011c07a7e38e60">More...</a><br /></td></tr>
<tr class="separator:aa70526dde51ab18ec4011c07a7e38e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75103b55ce8129ffad6bc721162daa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#af75103b55ce8129ffad6bc721162daa4">checkDir</a> (<a class="el" href="structmoveArray.html">moveArray</a> &amp;result, const <a class="el" href="structcheck.html">check</a> &amp;kingEnv, const <a class="el" href="structsquare.html">square</a>&lt; int &gt; basePos, const <a class="el" href="structsquare.html">square</a>&lt; int &gt; dir) const </td></tr>
<tr class="memdesc:af75103b55ce8129ffad6bc721162daa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the possible moves of a piece along some file, rank or diagonal.  <a href="#af75103b55ce8129ffad6bc721162daa4">More...</a><br /></td></tr>
<tr class="separator:af75103b55ce8129ffad6bc721162daa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc291baf2c205a64255e8e55ffeff004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcheck.html">check</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#afc291baf2c205a64255e8e55ffeff004">getCheck</a> (const <a class="el" href="structsquare.html">square</a>&lt; int &gt; kingPos)</td></tr>
<tr class="memdesc:afc291baf2c205a64255e8e55ffeff004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the details about a possible check at kingPos.  <a href="#afc291baf2c205a64255e8e55ffeff004">More...</a><br /></td></tr>
<tr class="separator:afc291baf2c205a64255e8e55ffeff004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36298e9258372ab79f6b9fe7c6d68725"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a36298e9258372ab79f6b9fe7c6d68725">firstPiece</a> (<a class="el" href="structcheck.html">check</a> &amp;result, const <a class="el" href="structsquare.html">square</a>&lt; int &gt; curPos, const <a class="el" href="structsquare.html">square</a>&lt; int &gt; dir, const int friendlies) const </td></tr>
<tr class="memdesc:a36298e9258372ab79f6b9fe7c6d68725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Investigate the possibility of attacks from dir to curPos (recursive) with heatmap.  <a href="#a36298e9258372ab79f6b9fe7c6d68725">More...</a><br /></td></tr>
<tr class="separator:a36298e9258372ab79f6b9fe7c6d68725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f65a6eb6397e49411afac21fbde0f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63f65a6eb6397e49411afac21fbde0f9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a63f65a6eb6397e49411afac21fbde0f9">isAttacked</a> (const <a class="el" href="structsquare.html">square</a>&lt; int &gt; piecePos) const </td></tr>
<tr class="memdesc:a63f65a6eb6397e49411afac21fbde0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the square&lt;int&gt; at piecePos is attacked. <br /></td></tr>
<tr class="separator:a63f65a6eb6397e49411afac21fbde0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a977ba17a7e6d6b669777566165b35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#ab3a977ba17a7e6d6b669777566165b35">hasAttacker</a> (<a class="el" href="structsquare.html">square</a>&lt; int &gt; pos, const <a class="el" href="structsquare.html">square</a>&lt; int &gt; dir) const </td></tr>
<tr class="memdesc:ab3a977ba17a7e6d6b669777566165b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invesitgate the possibility of attacks from dir at curPos.  <a href="#ab3a977ba17a7e6d6b669777566165b35">More...</a><br /></td></tr>
<tr class="separator:ab3a977ba17a7e6d6b669777566165b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f66a7e8970e2aa204785de11655c00e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f66a7e8970e2aa204785de11655c00e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a4f66a7e8970e2aa204785de11655c00e">isFriendly</a> (const <a class="el" href="namespacePiece.html#a588233307aa6bdb32c1d62c9f20895cc">Piece::Piece</a> piece) const </td></tr>
<tr class="memdesc:a4f66a7e8970e2aa204785de11655c00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if a piece is friendly. <br /></td></tr>
<tr class="separator:a4f66a7e8970e2aa204785de11655c00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0c7f2b780d03bea4db3e3092f6ee01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a0c7f2b780d03bea4db3e3092f6ee01"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a0a0c7f2b780d03bea4db3e3092f6ee01">isFriendly</a> (const <a class="el" href="structsquare.html">square</a>&lt; int &gt; pos) const </td></tr>
<tr class="memdesc:a0a0c7f2b780d03bea4db3e3092f6ee01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if a square is occupied by a friendly piece. <br /></td></tr>
<tr class="separator:a0a0c7f2b780d03bea4db3e3092f6ee01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632d2e0f09a1ad6fe835dc11ef1238cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a632d2e0f09a1ad6fe835dc11ef1238cc">Board</a> (const <a class="el" href="classBoard.html">Board</a> &amp;other, const <a class="el" href="structmove.html">move</a> mv)</td></tr>
<tr class="memdesc:a632d2e0f09a1ad6fe835dc11ef1238cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private constructor to circumvent calculating the possible legal moves twice.  <a href="#a632d2e0f09a1ad6fe835dc11ef1238cc">More...</a><br /></td></tr>
<tr class="separator:a632d2e0f09a1ad6fe835dc11ef1238cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea5a9ddcdeb6e4c087f53e71f6c11ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#aeea5a9ddcdeb6e4c087f53e71f6c11ec">flipBoard</a> ()</td></tr>
<tr class="memdesc:aeea5a9ddcdeb6e4c087f53e71f6c11ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip the board such that pawns always advance in the direction of increasing rank.  <a href="#aeea5a9ddcdeb6e4c087f53e71f6c11ec">More...</a><br /></td></tr>
<tr class="separator:aeea5a9ddcdeb6e4c087f53e71f6c11ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:acdbd7620b4c8bc08b2e42623c2a12a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacePiece.html#a588233307aa6bdb32c1d62c9f20895cc">Piece::Piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#acdbd7620b4c8bc08b2e42623c2a12a39">board</a> [8][8]</td></tr>
<tr class="separator:acdbd7620b4c8bc08b2e42623c2a12a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a6e23b1b18542b10938f2b333862f1"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#a46a6e23b1b18542b10938f2b333862f1">state</a></td></tr>
<tr class="separator:a46a6e23b1b18542b10938f2b333862f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3145585c03f739311c35fa8f3277d3"><td class="memItemLeft" align="right" valign="top">signed char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#aad3145585c03f739311c35fa8f3277d3">enPassant</a></td></tr>
<tr class="separator:aad3145585c03f739311c35fa8f3277d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6a2575c3bc280ddc9e445efd213e14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmoveArray.html">moveArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoard.html#aaf6a2575c3bc280ddc9e445efd213e14">legalMoves</a></td></tr>
<tr class="separator:aaf6a2575c3bc280ddc9e445efd213e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Objects of the <a class="el" href="classBoard.html">Board</a> class store exactly one position on the chess board. Methods of this class include methods to calculate the all legal moves in the position, and executing a move to obtain a new position. A lot of optimization has gone into the methods of <a class="el" href="classBoard.html">Board</a> and their internal communication. The following flowchart shows the respective contribution of the methods to the total runtime of the program. It was created using google-pprof. </p><div class="image">
<img src="../../img/timing.png" alt="timing.png"/>
</div>
  </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a632d2e0f09a1ad6fe835dc11ef1238cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Board::Board </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBoard.html">Board</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmove.html">move</a>&#160;</td>
          <td class="paramname"><em>mv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private constructor to circumvent calculating the possible legal moves twice. </p>
<p>This constructor is used when a move is executed. All the pieces must be copied, but copying all the legal moves is not necessary, as they are recalculated anyway. So, this private constructur is only to be used internally, when calling the <em>cloneAndExecMove</em> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>This is the board that is to be cloned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mv</td><td>This is the move that is to be executed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8dd2a85d6b43bcab4eaf83e1541aeb18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Board::Board </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from FEN notation from file or string and calculate legal moves. </p>
<p><a class="el" href="classBoard.html">Board</a> constructor creating <a class="el" href="classBoard.html">Board</a> object from either a file or a string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Either the FEN string or the filename </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>Boolean whether to read file or string (true is file) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad4d3ebb2342b74d9455a89924a54aa14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Board::calcMoves </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate legal moves. </p>
<p>This function calculates all possible moves, and stores them in <em>legalMoves</em> member. Additionally, it updates the <em>check</em> flag, to indicate whether the player that is to move is check. Finally, it also updates the <em>draw</em> flag. If there are too few pieces on the board for any mate to occur, then this flag is set. </p>

</div>
</div>
<a class="anchor" id="af75103b55ce8129ffad6bc721162daa4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Board::checkDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmoveArray.html">moveArray</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcheck.html">check</a> &amp;&#160;</td>
          <td class="paramname"><em>kingEnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsquare.html">square</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>basePos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsquare.html">square</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the possible moves of a piece along some file, rank or diagonal. </p>
<p>This function helps the getPieceMoves function. It checks to which squares a long range piece (i.e. queen, rook or bishop) can move in a given direction, and appends these moves to the array of legal moves. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>This is the array of moves which the found legal moves are appended to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kingEnv</td><td>Through this <em>check</em> object, the information concerning whether a given move resolves check is supplied to the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basePos</td><td>This is the position of the piece whose legal moves are investigated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>This is the direction in which the legal moves are being checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef2523a362ab327fb628f4f226db52de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBoard.html">Board</a> Board::cloneAndExecMove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmove.html">move</a>&#160;</td>
          <td class="paramname"><em>mv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone the current position and execute a move. </p>
<p>Clone the board and execute the given move. Return the resulting position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mv</td><td>The move to be executed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns a new <a class="el" href="classBoard.html">Board</a> object, containing the new position, after the move was executed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5732564ae8ce7f247072ded83f71dc75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Board::execMove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmove.html">move</a>&#160;</td>
          <td class="paramname"><em>move</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a move. </p>
<p>Execute a move on a given board and consequently flip the board and recalculate the legal moves. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">move</td><td>This is the move that is to be executed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36298e9258372ab79f6b9fe7c6d68725"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Board::firstPiece </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcheck.html">check</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsquare.html">square</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>curPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsquare.html">square</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>friendlies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Investigate the possibility of attacks from dir to curPos (recursive) with heatmap. </p>
<p>This function helps the getCheck function to investigate the influence of one of the 8 directions on the output of the getCheck function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The check struct that getCheck is working on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">curPos</td><td>The current position that is being investigated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>The direction in which is being checked whether there are attacks going on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">friendlies</td><td>This value determines the number of friendly pieces that were already encountered. If this is 1, and an attacking piece is encountered, then <em>result</em> will indicate that this piece is pinned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns a boolean. True is returned, if the square indicated by <em>curPos</em> is under attack from the direction indicated by <em>dir</em>. Otherwise, false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="aeea5a9ddcdeb6e4c087f53e71f6c11ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Board::flipBoard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flip the board such that pawns always advance in the direction of increasing rank. </p>
<p>This function flips the board. More precisely, it mirrors the position of all pieces along the axis between the 4th and 5th rank. So, for example, a piece on e3 is placed on e6, and a piece on a8 is placed on a1. This function is used to ensure that the player that is to move always plays with its pawns advancing to ever higher ranks. </p>

</div>
</div>
<a class="anchor" id="a4043087fc35e9706d0e83ec07225fe33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Board::fromFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the FEN notation from a file. </p>
<p>Initialize a <a class="el" href="classBoard.html">Board</a> object from a file containing a string in FEN notation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>The name of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns an error code, according to the following table: <table class="doxtable">
<tr>
<th align="right">Code </th><th>Description  </th></tr>
<tr>
<td align="right">0 </td><td>Success. </td></tr>
<tr>
<td align="right">1 </td><td>The syntax of str is wrong. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a49045c77d568e4b5a00f176a2add54c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Board::fromStr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the FEN notation from a string. </p>
<p>Initialize a <a class="el" href="classBoard.html">Board</a> object from a string in FEN notation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string in FEN notation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns an error code, according to the following table: <table class="doxtable">
<tr>
<th align="right">Code </th><th>Description  </th></tr>
<tr>
<td align="right">0 </td><td>Success. </td></tr>
<tr>
<td align="right">1 </td><td>The syntax of str is wrong. </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="afc291baf2c205a64255e8e55ffeff004"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcheck.html">check</a> Board::getCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsquare.html">square</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>kingPos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the details about a possible check at kingPos. </p>
<p>This function finds out what is going on in relation to the king of the player that is to move. In particular, it returns a check struct containing information about pinned pieces and squares that can resolve check. Moreover, it updates the check flag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kingPos</td><td>The position of the king. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns a check object, containing information about pinned pieces and, in case of check, how many pieces are attacking the king, and, in case of 1 attacking piece, which squares will resolve the check. </dd></dl>

</div>
</div>
<a class="anchor" id="aa70526dde51ab18ec4011c07a7e38e60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Board::getPieceMoves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmoveArray.html">moveArray</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcheck.html">check</a> &amp;&#160;</td>
          <td class="paramname"><em>kingEnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsquare.html">square</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>curPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsquare.html">square</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>kingPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the legal moves of the piece on square&lt;int&gt; curPos. </p>
<p>This function helps the calcMoves function. It investigates the legal moves that one particular piece can make, and appends these to the temporary moves array created by calcMoves. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>This is the array that the newly found moves are being appended to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kingEnv</td><td>The function uses this data structure to check whether the piece is pinned, or helps resolving a check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">curPos</td><td>This is the square where the piece, whose legal moves are begin investigated, is located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kingPos</td><td>This is the square where the king of the player who is to move is located. Its value is used to speed up special cases of taking en passant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3a977ba17a7e6d6b669777566165b35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Board::hasAttacker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsquare.html">square</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsquare.html">square</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invesitgate the possibility of attacks from dir at curPos. </p>
<p>This function helps the isAttacked function to determine whether an attack over a long distance from a fixed direction occurs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The position of which is determined whether it is under attack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>The direction in which is being checked whether there is an attacker. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns a boolean, indicating whether there is an emeny piece attacking the square <em>pos</em> from direction <em>dir</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a58b38efec8c8ce21b55546da09685a3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Board::printBoard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a formatted representation of the board. </p>
<p>Give a nice overview of the current position in the terminal window </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="acdbd7620b4c8bc08b2e42623c2a12a39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacePiece.html#a588233307aa6bdb32c1d62c9f20895cc">Piece::Piece</a> Board::board[8][8]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This character array stores the position of the pieces on the board. Every entry in the character array corresponds to one square. The values of these characters correspond to the widely used FEN notation. </p><table class="doxtable">
<tr>
<th>Value </th><th>ASCII representation </th><th><a class="el" href="namespacePiece.html">Piece</a>  </th></tr>
<tr>
<td>0x20 </td><td>Space </td><td>None </td></tr>
<tr>
<td>0x4B </td><td>K </td><td>White king </td></tr>
<tr>
<td>0x51 </td><td>Q </td><td>White queen </td></tr>
<tr>
<td>0x52 </td><td>R </td><td>White rook </td></tr>
<tr>
<td>0x42 </td><td>B </td><td>White bishop </td></tr>
<tr>
<td>0x4E </td><td>N </td><td>White knight </td></tr>
<tr>
<td>0x50 </td><td>P </td><td>White pawn </td></tr>
<tr>
<td>0x6B </td><td>k </td><td>Black king </td></tr>
<tr>
<td>0x71 </td><td>q </td><td>Black queen </td></tr>
<tr>
<td>0x72 </td><td>r </td><td>Black rook </td></tr>
<tr>
<td>0x62 </td><td>b </td><td>Black bishop </td></tr>
<tr>
<td>0x6E </td><td>n </td><td>Black knight </td></tr>
<tr>
<td>0x70 </td><td>p </td><td>Black pawn </td></tr>
</table>
<p>A convenient feature of this notation is that determining whether a piece is black can be done by doing an AND operation with the bitmask 0x20. </p>

</div>
</div>
<a class="anchor" id="aad3145585c03f739311c35fa8f3277d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed char Board::enPassant</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signed character stores whether the opponent in the last move advanced one of his pawns by two squares. If he did not, then the value is -1. Otherwise, it is in the range 0-7, where the value corresponds to the file on which the pawn was advanced in the last move. </p>

</div>
</div>
<a class="anchor" id="aaf6a2575c3bc280ddc9e445efd213e14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmoveArray.html">moveArray</a> Board::legalMoves</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Here, all the legal moves that the player to move can play are stored. We have chosen not to go with the std::vector&lt;move&gt; implementation, as our custom implementation saves about 15% of runtime. </p>

</div>
</div>
<a class="anchor" id="a46a6e23b1b18542b10938f2b333862f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char Board::state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This character contains seven flags. These flags store some auxiliary information about the position. They are listed in the table below. </p><table class="doxtable">
<tr>
<th>Bit </th><th>Keyword </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>checkMask </td><td>This flag is set if the player to move is checked. </td></tr>
<tr>
<td>1 </td><td>whiteCastleKingsideMask </td><td>This flag is set if the player to move has not yet moved his king and kingside rook. </td></tr>
<tr>
<td>2 </td><td>whiteCastleQueensideMask </td><td>This flag is set if the player to move has not yet moved his king and queenside rook. </td></tr>
<tr>
<td>3 </td><td>blackCastleKingsideMask </td><td>This flag is set if the player that is not to move has not yet moved his king and kingside rook. </td></tr>
<tr>
<td>4 </td><td>blackCastleQueensideMask </td><td>This flag is set if the player that is not to move has not yet moved his king and queenside rook. </td></tr>
<tr>
<td>5 </td><td>blackToMoveMask </td><td>This flag is set if black currently is to move. </td></tr>
<tr>
<td>6 </td><td>drawMask </td><td>This flag is set if there is a stalemate, or if giving checkmate with the pieces that are left on the board is not possible. In both cases, the game is considered to be drawn. </td></tr>
</table>
<p>Notice that it is no coincidence that the blackToMoveMask corresponds to the fifth bit. The fifth bit being set in a character yields 0x20, which is exactly the mask that can be used to determine whether a piece is black or white. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="Board_8h_source.html">Board.h</a></li>
<li>src/Board.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
